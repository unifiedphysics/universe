<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified Physics: Fibonacci Spiral Filaments</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            overflow: hidden; 
            font-family: Georgia, serif;
            color: #fff;
        }
        #container { width: 100vw; height: 100vh; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 10px;
            max-width: 320px;
            border: 1px solid #333;
        }
        #info h1 { font-size: 16px; margin-bottom: 10px; color: #4ecdc4; }
        #info p { font-size: 11px; line-height: 1.5; margin-bottom: 8px; color: #aaa; }
        .gold { color: #ffd166; }
        .cyan { color: #4ecdc4; }
        .red { color: #ff6b6b; }
        .green { color: #00ff88; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            font-size: 11px;
        }
        #controls label { display: block; margin: 8px 0; }
        #controls input[type="range"] { width: 180px; vertical-align: middle; }
        #controls input[type="checkbox"] { vertical-align: middle; margin-right: 5px; }
        .fib-note { color: #ffd166; font-size: 10px; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="info">
        <h1>κ Flowing as Fibonacci Spirals</h1>
        <p><span class="cyan">● 13 Filaments:</span> Emerge from spine, spiral at golden angle (137.5°). Count dictated by Fibonacci sequence.</p>
        <p><span class="gold">● φ Lock Point (pinch):</span> Cross-section → 0. All filaments unified. κ passes through, spirals back out.</p>
        <p><span class="green">● Green Disc (2012):</span> Cross-sectional slice at maximum expansion - the observable universe.</p>
        <p><span class="red">— Spine:</span> The c-thread running through the center.</p>
        <p style="margin-top: 12px; color: #666;">Drag to rotate • Scroll to zoom</p>
    </div>
    
    <div id="controls">
        <label>Auto-Rotate: <input type="range" id="rotationSpeed" min="0" max="50" value="10"></label>
        <label><input type="checkbox" id="showSpine" checked> Show Spine</label>
        <label><input type="checkbox" id="showFilaments" checked> Show Filaments</label>
        <label><input type="checkbox" id="showCrossSection" checked> Show 2012 Cross-Section</label>
        <p class="fib-note">Filament count: 13 (Fibonacci)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        const PHI = (1 + Math.sqrt(5)) / 2;
        const GOLDEN_ANGLE = Math.PI * 2 / (PHI * PHI);
        const NUM_FILAMENTS = 13;

        let isDragging = false;
        let spherical = { theta: Math.PI / 2, phi: Math.PI / 3, radius: 40 };
        let lastMouse = { x: 0, y: 0 };

        document.addEventListener('mousedown', (e) => { 
            isDragging = true; 
            lastMouse = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('mouseup', () => { isDragging = false; });
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouse.x;
                const dy = e.clientY - lastMouse.y;
                spherical.theta -= dx * 0.005;
                spherical.phi -= dy * 0.005;
                spherical.phi = Math.max(0.2, Math.min(Math.PI - 0.2, spherical.phi));
                lastMouse = { x: e.clientX, y: e.clientY };
            }
        });
        document.addEventListener('wheel', (e) => {
            spherical.radius += e.deltaY * 0.03;
            spherical.radius = Math.max(15, Math.min(100, spherical.radius));
        });

        const MAJOR_RADIUS = 12;
        const MIN_CROSS_RADIUS = 0.08;
        const MAX_CROSS_RADIUS = 5;

        function getCrossRadius(t) {
            const normalized = Math.sin(t / 2);
            return MIN_CROSS_RADIUS + (MAX_CROSS_RADIUS - MIN_CROSS_RADIUS) * Math.pow(normalized, 2.5);
        }

        function getTorusCenter(t) {
            return new THREE.Vector3(
                Math.cos(t) * MAJOR_RADIUS,
                0,
                Math.sin(t) * MAJOR_RADIUS
            );
        }
        
        function getCrossSectionVectors(t) {
            const tangent = new THREE.Vector3(-Math.sin(t), 0, Math.cos(t));
            const up = new THREE.Vector3(0, 1, 0);
            const radial = new THREE.Vector3(Math.cos(t), 0, Math.sin(t));
            return { tangent, up, radial };
        }

        function getTorusPoint(t, theta, radiusFraction = 1.0) {
            const crossRadius = getCrossRadius(t) * radiusFraction;
            const center = getTorusCenter(t);
            const { radial } = getCrossSectionVectors(t);
            
            const x = center.x + radial.x * Math.cos(theta) * crossRadius;
            const y = center.y + Math.sin(theta) * crossRadius;
            const z = center.z + radial.z * Math.cos(theta) * crossRadius;
            
            return new THREE.Vector3(x, y, z);
        }

        function createFilaments() {
            const group = new THREE.Group();
            
            for (let f = 0; f < NUM_FILAMENTS; f++) {
                const points = [];
                const colors = [];
                const segments = 400;
                
                const startTheta = f * GOLDEN_ANGLE;
                
                for (let i = 0; i <= segments; i++) {
                    const t = (i / segments) * Math.PI * 2;
                    
                    const theta = startTheta + (t / (Math.PI * 2)) * NUM_FILAMENTS * GOLDEN_ANGLE;
                    
                    const crossRadius = getCrossRadius(t);
                    const maxCross = getCrossRadius(Math.PI);
                    const frayFraction = crossRadius / maxCross;
                    
                    const point = getTorusPoint(t, theta, frayFraction);
                    points.push(point);
                    
                    let r, g, b;
                    const progress = t / (Math.PI * 2);
                    const distFromPinch = Math.min(progress, 1 - progress);
                    
                    if (distFromPinch < 0.1) {
                        const fade = distFromPinch / 0.1;
                        r = 1 * fade; g = 0.82 * fade; b = 0.4 * fade;
                    } else if (progress < 0.4) {
                        const blend = (progress - 0.1) / 0.3;
                        r = 1 - blend * 0.7; g = 0.82; b = 0.4 + blend * 0.37;
                    } else if (progress < 0.6) {
                        r = 0.3; g = 0.82; b = 0.77;
                    } else if (progress < 0.9) {
                        const blend = (progress - 0.6) / 0.3;
                        r = 0.3 + blend * 0.7; g = 0.82; b = 0.77 - blend * 0.37;
                    } else {
                        const fade = 1 - (progress - 0.9) / 0.1;
                        r = 1 * fade; g = 0.82 * fade; b = 0.4 * fade;
                    }
                    
                    colors.push(r, g, b);
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.LineBasicMaterial({ 
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.75
                });
                
                group.add(new THREE.Line(geometry, material));
            }
            
            return group;
        }

        // SPINE: Just one thin line through the center
        function createSpine() {
            const points = [];
            const colors = [];
            
            for (let i = 0; i <= 200; i++) {
                const t = (i / 200) * Math.PI * 2;
                points.push(getTorusCenter(t));
                
                // Color: brighter near pinch, dimmer at max expansion
                const progress = t / (Math.PI * 2);
                const distFromPinch = Math.min(progress, 1 - progress);
                const brightness = 0.4 + 0.6 * (1 - Math.min(distFromPinch * 3, 1));
                
                colors.push(brightness, brightness * 0.3, brightness * 0.3);
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({ 
                vertexColors: true,
                transparent: true,
                opacity: 0.9
            });
            
            return new THREE.Line(geometry, material);
        }

        function createPinchMarker() {
            const group = new THREE.Group();
            
            const glowGeo = new THREE.SphereGeometry(0.2, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xffd700,
                transparent: true,
                opacity: 0.9
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.set(MAJOR_RADIUS, 0, 0);
            group.add(glow);
            
            return group;
        }

        function createCrossSectionDisc() {
            const group = new THREE.Group();
            
            const t = Math.PI;
            const crossRadius = getCrossRadius(t);
            const center = getTorusCenter(t);
            
            const discGeo = new THREE.CircleGeometry(crossRadius, 64);
            const discMat = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const disc = new THREE.Mesh(discGeo, discMat);
            disc.position.copy(center);
            group.add(disc);
            
            // Edge ring
            const edgePoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                edgePoints.push(new THREE.Vector3(
                    center.x + Math.cos(angle) * crossRadius,
                    center.y + Math.sin(angle) * crossRadius,
                    center.z
                ));
            }
            const edgeGeo = new THREE.BufferGeometry().setFromPoints(edgePoints);
            const edgeMat = new THREE.LineBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.7
            });
            group.add(new THREE.Line(edgeGeo, edgeMat));
            
            // Center point (where spine passes through)
            const centerGeo = new THREE.SphereGeometry(0.1, 16, 16);
            const centerMat = new THREE.MeshBasicMaterial({
                color: 0xff6666,
                transparent: true,
                opacity: 0.9
            });
            const centerDot = new THREE.Mesh(centerGeo, centerMat);
            centerDot.position.copy(center);
            group.add(centerDot);
            
            // Radial lines
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const linePoints = [
                    new THREE.Vector3(center.x, center.y, center.z),
                    new THREE.Vector3(
                        center.x + Math.cos(angle) * crossRadius,
                        center.y + Math.sin(angle) * crossRadius,
                        center.z
                    )
                ];
                const lineGeo = new THREE.BufferGeometry().setFromPoints(linePoints);
                const lineMat = new THREE.LineBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.3
                });
                group.add(new THREE.Line(lineGeo, lineMat));
            }
            
            return group;
        }

        // Build scene
        const spine = createSpine();
        scene.add(spine);
        
        const pinchMarker = createPinchMarker();
        scene.add(pinchMarker);

        const crossSectionDisc = createCrossSectionDisc();
        scene.add(crossSectionDisc);

        const filaments = createFilaments();
        scene.add(filaments);

        function animate() {
            requestAnimationFrame(animate);
            
            const rotateSpeed = document.getElementById('rotationSpeed').value / 3000;
            spherical.theta += rotateSpeed;
            
            camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
            camera.position.y = spherical.radius * Math.cos(spherical.phi);
            camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
            camera.lookAt(0, 0, 0);
            
            spine.visible = document.getElementById('showSpine').checked;
            filaments.visible = document.getElementById('showFilaments').checked;
            crossSectionDisc.visible = document.getElementById('showCrossSection').checked;
            
            const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.004);
            pinchMarker.children[0].material.opacity = pulse;
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
